<?xml version="1.0" encoding="UTF-8" ?>
<testsuites name="vitest tests" tests="438" failures="27" errors="0" time="2.410048003">
    <testsuite name="src/commands/base.test.ts" timestamp="2025-08-11T18:03:48.296Z" hostname="Emmanuels-MacBook-Air.local" tests="8" failures="0" errors="0" skipped="0" time="0.021745209">
        <testcase classname="src/commands/base.test.ts" name="CommandContext &gt; should define correct interface structure" time="0.015960375">
        </testcase>
        <testcase classname="src/commands/base.test.ts" name="CommandContext &gt; should work with minimal required properties" time="0.000272042">
        </testcase>
        <testcase classname="src/commands/base.test.ts" name="CommandDefinition &gt; should define correct interface structure" time="0.000106333">
        </testcase>
        <testcase classname="src/commands/base.test.ts" name="BaseCommand &gt; should create a command instance with required properties" time="0.000089375">
        </testcase>
        <testcase classname="src/commands/base.test.ts" name="BaseCommand &gt; should execute handler correctly" time="0.003421417">
        </testcase>
        <testcase classname="src/commands/base.test.ts" name="BaseCommand &gt; should implement CommandDefinition interface" time="0.000134375">
        </testcase>
        <testcase classname="src/commands/base.test.ts" name="BaseCommand &gt; should handle optional context properties" time="0.000267041">
        </testcase>
        <testcase classname="src/commands/base.test.ts" name="BaseCommand &gt; should handle missing optional context properties gracefully" time="0.000602416">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/index.test.ts" timestamp="2025-08-11T18:03:48.297Z" hostname="Emmanuels-MacBook-Air.local" tests="18" failures="0" errors="0" skipped="0" time="0.007922083">
        <testcase classname="src/commands/index.test.ts" name="getAvailableCommands &gt; should return an array of command definitions" time="0.00137175">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="getAvailableCommands &gt; should return a copy of commands array (not mutate original)" time="0.000632959">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="getAvailableCommands &gt; should include expected command types" time="0.000582">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="getCommandNames &gt; should return array of command names" time="0.000171125">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="getCommandNames &gt; should return lowercase command names" time="0.000077667">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="getCommandNames &gt; should match command names from getAvailableCommands" time="0.000063875">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should add user message for any command" time="0.001398041">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should execute valid command handler" time="0.000221292">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should handle command with case insensitivity" time="0.000164667">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should handle command with mixed case" time="0.000144125">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should handle command with arguments (space separated)" time="0.000151292">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should handle unknown command gracefully" time="0.000127292">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should extract command name correctly from complex input" time="0.000227291">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should handle command without space at the end" time="0.000168125">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should handle empty command gracefully" time="0.000145042">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should handle reasoning command toggle" time="0.000128833">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should handle commands with different function availability" time="0.000172375">
        </testcase>
        <testcase classname="src/commands/index.test.ts" name="handleSlashCommand &gt; should handle all available commands" time="0.001006916">
        </testcase>
    </testsuite>
    <testsuite name="src/core/agent.test.ts" timestamp="2025-08-11T18:03:48.299Z" hostname="Emmanuels-MacBook-Air.local" tests="33" failures="0" errors="0" skipped="0" time="0.04556125">
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Agent.create &gt; should create agent with provided model" time="0.004069416">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Agent.create &gt; should use default model from config if available" time="0.000399167">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Agent.create &gt; should use provided model if no default in config" time="0.000229042">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Agent.create &gt; should accept custom system message" time="0.000229708">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; API Key Management &gt; should set API key" time="0.001308625">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; API Key Management &gt; should save API key" time="0.001509542">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; API Key Management &gt; should clear API key" time="0.000336541">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Model Management &gt; should set and get current model" time="0.000319">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Model Management &gt; should update system message when model changes" time="0.00036275">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Session Management &gt; should set session auto approve" time="0.000661416">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Session Management &gt; should clear history" time="0.0002965">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Session Management &gt; should set tool callbacks" time="0.000354">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Session Management &gt; should handle interrupt" time="0.000265542">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should throw error when no API key available" time="0.013424208">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should use API key from environment variable" time="0.000706041">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should use API key from config file when env var not available" time="0.000328542">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle simple chat without tools" time="0.000365166">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle chat with reasoning" time="0.00028925">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle tool calls" time="0.001295083">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle tool call approval" time="0.000758709">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle tool call rejection" time="0.001200708">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle session auto approval" time="0.000913792">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle read-before-edit validation failure" time="0.0007855">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle truncated tool arguments" time="0.001008667">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle API errors gracefully" time="0.004009458">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle 401 API errors by throwing immediately" time="0.000670459">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle max iterations with user continuation" time="0.000718708">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should handle interruption during chat" time="0.000448625">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Chat Functionality &gt; should strip repo_browser prefix from tool names" time="0.000561791">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Error Handling &gt; should handle tool execution errors" time="0.000944708">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Error Handling &gt; should handle missing Groq client" time="0.000386667">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Debug Functionality &gt; should create agent with debug enabled" time="0.002943875">
        </testcase>
        <testcase classname="src/core/agent.test.ts" name="Agent &gt; Debug Functionality &gt; should handle debug logging without errors" time="0.00125075">
        </testcase>
    </testsuite>
    <testsuite name="src/tools/tool-schemas.test.ts" timestamp="2025-08-11T18:03:48.301Z" hostname="Emmanuels-MacBook-Air.local" tests="44" failures="0" errors="0" skipped="0" time="0.007494709">
        <testcase classname="src/tools/tool-schemas.test.ts" name="ToolSchema Interface &gt; should define correct structure" time="0.000900334">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="READ_FILE_SCHEMA &gt; should have correct structure and properties" time="0.000572083">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="READ_FILE_SCHEMA &gt; should have correct parameter definitions" time="0.00020875">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="READ_FILE_SCHEMA &gt; should include usage guidelines" time="0.000066417">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="CREATE_FILE_SCHEMA &gt; should have correct structure and properties" time="0.000098833">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="CREATE_FILE_SCHEMA &gt; should have file type enumeration" time="0.000075292">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="CREATE_FILE_SCHEMA &gt; should have overwrite option" time="0.00005475">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="CREATE_FILE_SCHEMA &gt; should include safety warnings" time="0.00005275">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="EDIT_FILE_SCHEMA &gt; should have correct structure and properties" time="0.000095791">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="EDIT_FILE_SCHEMA &gt; should have replace_all option" time="0.000053125">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="EDIT_FILE_SCHEMA &gt; should include mandatory requirements" time="0.000059875">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="DELETE_FILE_SCHEMA &gt; should have correct structure and properties" time="0.000099583">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="DELETE_FILE_SCHEMA &gt; should have recursive option" time="0.000051625">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="DELETE_FILE_SCHEMA &gt; should include caution warning" time="0.000037042">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="EXECUTE_COMMAND_SCHEMA &gt; should have correct structure and properties" time="0.000092958">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="EXECUTE_COMMAND_SCHEMA &gt; should have command type enumeration" time="0.000047834">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="EXECUTE_COMMAND_SCHEMA &gt; should have timeout constraints" time="0.000048042">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="EXECUTE_COMMAND_SCHEMA &gt; should include safety warnings" time="0.000046416">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="SEARCH_FILES_SCHEMA &gt; should have correct structure and properties" time="0.000077459">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="SEARCH_FILES_SCHEMA &gt; should have pattern type enumeration" time="0.0000555">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="SEARCH_FILES_SCHEMA &gt; should have result limits" time="0.000056375">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="SEARCH_FILES_SCHEMA &gt; should have context line constraints" time="0.000053708">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="LIST_FILES_SCHEMA &gt; should have correct structure and properties" time="0.000078584">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="LIST_FILES_SCHEMA &gt; should have default values" time="0.000065667">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="LIST_FILES_SCHEMA &gt; should include file existence check guidance" time="0.000052291">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="CREATE_TASKS_SCHEMA &gt; should have correct structure and properties" time="0.000078916">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="CREATE_TASKS_SCHEMA &gt; should have task structure definition" time="0.000087">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="UPDATE_TASKS_SCHEMA &gt; should have correct structure and properties" time="0.000077416">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="UPDATE_TASKS_SCHEMA &gt; should have update structure definition" time="0.0000625">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="ALL_TOOL_SCHEMAS &gt; should contain all defined schemas" time="0.001039833">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="ALL_TOOL_SCHEMAS &gt; should have unique tool names" time="0.000098375">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="ALL_TOOL_SCHEMAS &gt; should all be function type" time="0.000107958">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="ALL_TOOL_SCHEMAS &gt; should all have descriptions and parameters" time="0.000340542">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="Tool Categories &gt; SAFE_TOOLS &gt; should contain read-only and task management tools" time="0.000055333">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="Tool Categories &gt; SAFE_TOOLS &gt; should be a subset of all tools" time="0.000247875">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="Tool Categories &gt; APPROVAL_REQUIRED_TOOLS &gt; should contain file modification tools" time="0.000051041">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="Tool Categories &gt; APPROVAL_REQUIRED_TOOLS &gt; should be a subset of all tools" time="0.000078458">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="Tool Categories &gt; DANGEROUS_TOOLS &gt; should contain destructive and execution tools" time="0.00004475">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="Tool Categories &gt; DANGEROUS_TOOLS &gt; should be a subset of all tools" time="0.000077125">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="Tool Categories &gt; should have no overlap between categories" time="0.000065667">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="Tool Categories &gt; should categorize all tools" time="0.000201166">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="Schema Validation &gt; should have consistent parameter descriptions" time="0.0005145">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="Schema Validation &gt; should have path parameters with consistent guidance" time="0.000120875">
        </testcase>
        <testcase classname="src/tools/tool-schemas.test.ts" name="Schema Validation &gt; should have directory parameters with consistent guidance" time="0.000059709">
        </testcase>
    </testsuite>
    <testsuite name="src/tools/tools.test.ts" timestamp="2025-08-11T18:03:48.304Z" hostname="Emmanuels-MacBook-Air.local" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/tools/tools.test.ts" name="src/tools/tools.test.ts" time="0">
            <failure message="promisify is not a function" type="TypeError">
TypeError: promisify is not a function
 ❯ src/tools/tools.ts:8:19
 ❯ src/tools/tools.test.ts:5:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/tools/validators.test.ts" timestamp="2025-08-11T18:03:48.304Z" hostname="Emmanuels-MacBook-Air.local" tests="9" failures="0" errors="0" skipped="0" time="0.00448275">
        <testcase classname="src/tools/validators.test.ts" name="validators &gt; validateReadBeforeEdit &gt; should return true when no tracker is set" time="0.001141542">
        </testcase>
        <testcase classname="src/tools/validators.test.ts" name="validators &gt; validateReadBeforeEdit &gt; should return true when file has been read" time="0.000113584">
        </testcase>
        <testcase classname="src/tools/validators.test.ts" name="validators &gt; validateReadBeforeEdit &gt; should return false when file has not been read" time="0.000066458">
        </testcase>
        <testcase classname="src/tools/validators.test.ts" name="validators &gt; validateReadBeforeEdit &gt; should handle relative paths correctly" time="0.000067917">
        </testcase>
        <testcase classname="src/tools/validators.test.ts" name="validators &gt; validateReadBeforeEdit &gt; should handle different path formats for same file" time="0.000060917">
        </testcase>
        <testcase classname="src/tools/validators.test.ts" name="validators &gt; getReadBeforeEditError &gt; should return error message with file path" time="0.000066375">
        </testcase>
        <testcase classname="src/tools/validators.test.ts" name="validators &gt; getReadBeforeEditError &gt; should handle relative paths in error message" time="0.000045417">
        </testcase>
        <testcase classname="src/tools/validators.test.ts" name="validators &gt; setReadFilesTracker &gt; should set tracker correctly" time="0.000069">
        </testcase>
        <testcase classname="src/tools/validators.test.ts" name="validators &gt; setReadFilesTracker &gt; should allow resetting tracker to null" time="0.0013565">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/App.test.tsx" timestamp="2025-08-11T18:03:48.305Z" hostname="Emmanuels-MacBook-Air.local" tests="11" failures="8" errors="0" skipped="0" time="0.062659375">
        <testcase classname="src/ui/App.test.tsx" name="App &gt; initialization &gt; should show loading state initially" time="0.019421833">
            <system-err>
React does not recognize the `justifyContent` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `justifycontent` instead. If you accidentally passed it from a parent component, remove it from the DOM element.
React does not recognize the `alignItems` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `alignitems` instead. If you accidentally passed it from a parent component, remove it from the DOM element.
React does not recognize the `flexDirection` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `flexdirection` instead. If you accidentally passed it from a parent component, remove it from the DOM element.

            </system-err>
            <failure message="Unable to find an element with the text: Initializing agent.... This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

Ignored nodes: comments, script, style
[36m&lt;body&gt;[39m
  [36m&lt;div&gt;[39m
    [36m&lt;div[39m
      [33mdata-testid[39m=[32m&quot;box&quot;[39m
      [33mflexdirection[39m=[32m&quot;column&quot;[39m
      [33mheight[39m=[32m&quot;100%&quot;[39m
    [36m&gt;[39m
      [36m&lt;div[39m
        [33mdata-testid[39m=[32m&quot;chat&quot;[39m
      [36m&gt;[39m
        [0mChat Component[0m
      [36m&lt;/div&gt;[39m
    [36m&lt;/div&gt;[39m
  [36m&lt;/div&gt;[39m
[36m&lt;/body&gt;[39m" type="TestingLibraryElementError">
TestingLibraryElementError: Unable to find an element with the text: Initializing agent.... This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

Ignored nodes: comments, script, style
&lt;body&gt;
  &lt;div&gt;
    &lt;div
      data-testid=&quot;box&quot;
      flexdirection=&quot;column&quot;
      height=&quot;100%&quot;
    &gt;
      &lt;div
        data-testid=&quot;chat&quot;
      &gt;
        Chat Component
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
 ❯ Object.getElementError node_modules/@testing-library/dom/dist/config.js:37:19
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:76:38
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:52:17
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:95:19
 ❯ src/ui/App.test.tsx:36:14
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App &gt; initialization &gt; should show Chat component after initialization" time="0.008815375">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App &gt; rendering &gt; should render with correct layout structure" time="0.002954208">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App &gt; rendering &gt; should pass agent prop to Chat component" time="0.010364125">
            <failure message="expected &quot;spy&quot; to be called with arguments: [ ObjectContaining{…}, Anything ][90m

Received: 

[1m  1st spy call:

[22m[2m  [[22m
[32m-   ObjectContaining {[90m
[31m+   {[90m
[2m      &quot;agent&quot;: {[22m
[2m        &quot;chat&quot;: [Function spy],[22m
[2m        &quot;interrupt&quot;: [Function spy],[22m
[2m        &quot;setApiKey&quot;: [Function spy],[22m
[2m        &quot;setReasoningDisplay&quot;: [Function spy],[22m
[2m        &quot;toggleAutoApprove&quot;: [Function spy],[22m
[2m      },[22m
[2m    },[22m
[32m-   Anything,[90m
[31m+   undefined,[90m
[2m  ][22m
[39m[90m

Number of calls: [1m1[22m
[39m" type="AssertionError">
AssertionError: expected &quot;spy&quot; to be called with arguments: [ ObjectContaining{…}, Anything ]

Received: 

  1st spy call:

  [
-   ObjectContaining {
+   {
      &quot;agent&quot;: {
        &quot;chat&quot;: [Function spy],
        &quot;interrupt&quot;: [Function spy],
        &quot;setApiKey&quot;: [Function spy],
        &quot;setReasoningDisplay&quot;: [Function spy],
        &quot;toggleAutoApprove&quot;: [Function spy],
      },
    },
-   Anything,
+   undefined,
  ]


Number of calls: 1

 ❯ src/ui/App.test.tsx:65:24
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App &gt; state management &gt; should properly manage isReady state" time="0.001915833">
            <failure message="Unable to find an element with the text: Initializing agent.... This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

Ignored nodes: comments, script, style
[36m&lt;body&gt;[39m
  [36m&lt;div&gt;[39m
    [36m&lt;div[39m
      [33mdata-testid[39m=[32m&quot;box&quot;[39m
      [33mflexdirection[39m=[32m&quot;column&quot;[39m
      [33mheight[39m=[32m&quot;100%&quot;[39m
    [36m&gt;[39m
      [36m&lt;div[39m
        [33mdata-testid[39m=[32m&quot;chat&quot;[39m
      [36m&gt;[39m
        [0mChat Component[0m
      [36m&lt;/div&gt;[39m
    [36m&lt;/div&gt;[39m
  [36m&lt;/div&gt;[39m
[36m&lt;/body&gt;[39m" type="TestingLibraryElementError">
TestingLibraryElementError: Unable to find an element with the text: Initializing agent.... This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

Ignored nodes: comments, script, style
&lt;body&gt;
  &lt;div&gt;
    &lt;div
      data-testid=&quot;box&quot;
      flexdirection=&quot;column&quot;
      height=&quot;100%&quot;
    &gt;
      &lt;div
        data-testid=&quot;chat&quot;
      &gt;
        Chat Component
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
 ❯ Object.getElementError node_modules/@testing-library/dom/dist/config.js:37:19
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:76:38
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:52:17
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:95:19
 ❯ src/ui/App.test.tsx:77:14
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App &gt; edge cases &gt; should handle null agent gracefully" time="0.0011685">
            <failure message="Unable to find an element with the text: Initializing agent.... This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

Ignored nodes: comments, script, style
[36m&lt;body&gt;[39m
  [36m&lt;div&gt;[39m
    [36m&lt;div[39m
      [33mdata-testid[39m=[32m&quot;box&quot;[39m
      [33mflexdirection[39m=[32m&quot;column&quot;[39m
      [33mheight[39m=[32m&quot;100%&quot;[39m
    [36m&gt;[39m
      [36m&lt;div[39m
        [33mdata-testid[39m=[32m&quot;chat&quot;[39m
      [36m&gt;[39m
        [0mChat Component[0m
      [36m&lt;/div&gt;[39m
    [36m&lt;/div&gt;[39m
  [36m&lt;/div&gt;[39m
[36m&lt;/body&gt;[39m" type="TestingLibraryElementError">
TestingLibraryElementError: Unable to find an element with the text: Initializing agent.... This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

Ignored nodes: comments, script, style
&lt;body&gt;
  &lt;div&gt;
    &lt;div
      data-testid=&quot;box&quot;
      flexdirection=&quot;column&quot;
      height=&quot;100%&quot;
    &gt;
      &lt;div
        data-testid=&quot;chat&quot;
      &gt;
        Chat Component
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
 ❯ Object.getElementError node_modules/@testing-library/dom/dist/config.js:37:19
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:76:38
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:52:17
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:95:19
 ❯ src/ui/App.test.tsx:90:14
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App &gt; edge cases &gt; should handle undefined agent gracefully" time="0.001969625">
            <failure message="Unable to find an element with the text: Initializing agent.... This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

Ignored nodes: comments, script, style
[36m&lt;body&gt;[39m
  [36m&lt;div&gt;[39m
    [36m&lt;div[39m
      [33mdata-testid[39m=[32m&quot;box&quot;[39m
      [33mflexdirection[39m=[32m&quot;column&quot;[39m
      [33mheight[39m=[32m&quot;100%&quot;[39m
    [36m&gt;[39m
      [36m&lt;div[39m
        [33mdata-testid[39m=[32m&quot;chat&quot;[39m
      [36m&gt;[39m
        [0mChat Component[0m
      [36m&lt;/div&gt;[39m
    [36m&lt;/div&gt;[39m
  [36m&lt;/div&gt;[39m
[36m&lt;/body&gt;[39m" type="TestingLibraryElementError">
TestingLibraryElementError: Unable to find an element with the text: Initializing agent.... This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

Ignored nodes: comments, script, style
&lt;body&gt;
  &lt;div&gt;
    &lt;div
      data-testid=&quot;box&quot;
      flexdirection=&quot;column&quot;
      height=&quot;100%&quot;
    &gt;
      &lt;div
        data-testid=&quot;chat&quot;
      &gt;
        Chat Component
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
 ❯ Object.getElementError node_modules/@testing-library/dom/dist/config.js:37:19
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:76:38
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:52:17
 ❯ node_modules/@testing-library/dom/dist/query-helpers.js:95:19
 ❯ src/ui/App.test.tsx:95:14
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App &gt; edge cases &gt; should handle re-renders with different agent" time="0.002591834">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App &gt; layout &gt; should use column flex direction" time="0.00231175">
            <failure message="Invalid Chai property: toHaveAttribute" type="Error">
Error: Invalid Chai property: toHaveAttribute
 ❯ src/ui/App.test.tsx:124:21
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App &gt; layout &gt; should set height to 100%" time="0.005326125">
            <failure message="Invalid Chai property: toHaveAttribute" type="Error">
Error: Invalid Chai property: toHaveAttribute
 ❯ src/ui/App.test.tsx:130:21
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App &gt; layout &gt; should center loading message" time="0.00460625">
            <failure message="expected undefined to be truthy" type="AssertionError">
AssertionError: expected undefined to be truthy

- Expected: 
true

+ Received: 
undefined

 ❯ src/ui/App.test.tsx:140:25
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/utils/constants.test.ts" timestamp="2025-08-11T18:03:48.307Z" hostname="Emmanuels-MacBook-Air.local" tests="6" failures="0" errors="0" skipped="0" time="0.002252625">
        <testcase classname="src/utils/constants.test.ts" name="constants &gt; IGNORE_PATTERNS &gt; should be a Set" time="0.000884583">
        </testcase>
        <testcase classname="src/utils/constants.test.ts" name="constants &gt; IGNORE_PATTERNS &gt; should contain common directories to ignore" time="0.000246458">
        </testcase>
        <testcase classname="src/utils/constants.test.ts" name="constants &gt; IGNORE_PATTERNS &gt; should contain Python-specific patterns" time="0.000103792">
        </testcase>
        <testcase classname="src/utils/constants.test.ts" name="constants &gt; IGNORE_PATTERNS &gt; should contain IDE-specific patterns" time="0.000062084">
        </testcase>
        <testcase classname="src/utils/constants.test.ts" name="constants &gt; IGNORE_PATTERNS &gt; should contain OS and temporary file patterns" time="0.000068458">
        </testcase>
        <testcase classname="src/utils/constants.test.ts" name="constants &gt; IGNORE_PATTERNS &gt; should have the expected number of patterns" time="0.000042083">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/file-ops.test.ts" timestamp="2025-08-11T18:03:48.308Z" hostname="Emmanuels-MacBook-Air.local" tests="24" failures="0" errors="0" skipped="0" time="0.021923">
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; writeFile &gt; should write file successfully" time="0.006927167">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; writeFile &gt; should return false on error" time="0.000502041">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; writeFile &gt; should handle force and backup parameters" time="0.000239542">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; createDirectory &gt; should create directory successfully" time="0.000282291">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; createDirectory &gt; should return false on error" time="0.000098708">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; deleteFile &gt; should delete file when force is true" time="0.000169625">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; deleteFile &gt; should delete directory when force is true" time="0.000121208">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; deleteFile &gt; should return false when force is false" time="0.000162125">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; deleteFile &gt; should return false when file does not exist" time="0.000091584">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; deleteFile &gt; should return false on other errors" time="0.00006725">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; displayTree &gt; should display directory tree" time="0.009232667">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; displayTree &gt; should handle directory not found" time="0.000160333">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; displayTree &gt; should filter hidden files when showHidden is false" time="0.00014825">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; displayTree &gt; should show hidden files when showHidden is true" time="0.000109958">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; displayTree &gt; should handle errors during readdir" time="0.000077541">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; shouldIgnore &gt; should ignore node_modules" time="0.000085167">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; shouldIgnore &gt; should ignore .git directory" time="0.000057375">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; shouldIgnore &gt; should ignore files matching glob patterns" time="0.000084584">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; shouldIgnore &gt; should ignore hidden files except allowed ones" time="0.000085625">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; shouldIgnore &gt; should not ignore regular files" time="0.000072458">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; shouldIgnore &gt; should ignore Python-specific patterns" time="0.00006225">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; shouldIgnore &gt; should ignore IDE directories" time="0.000051375">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; shouldIgnore &gt; should ignore build directories" time="0.000050833">
        </testcase>
        <testcase classname="src/utils/file-ops.test.ts" name="file-ops &gt; shouldIgnore &gt; should ignore OS-specific files" time="0.00004075">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/local-settings.test.ts" timestamp="2025-08-11T18:03:48.309Z" hostname="Emmanuels-MacBook-Air.local" tests="21" failures="0" errors="0" skipped="0" time="0.010919417">
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; constructor &gt; should initialize with correct config path" time="0.001755667">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; getApiKey &gt; should return null when config file does not exist" time="0.001459125">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; getApiKey &gt; should return API key from config file" time="0.000704625">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; getApiKey &gt; should return null when groqApiKey is not in config" time="0.000934542">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; getApiKey &gt; should return null and warn on JSON parse error" time="0.001215666">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; setApiKey &gt; should create config directory if it does not exist" time="0.000697458">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; setApiKey &gt; should create new config file with API key" time="0.000286292">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; setApiKey &gt; should update existing config file with API key" time="0.000175042">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; setApiKey &gt; should throw error on write failure" time="0.000692083">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; clearApiKey &gt; should do nothing if config file does not exist" time="0.0002695">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; clearApiKey &gt; should remove API key from config" time="0.000164041">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; clearApiKey &gt; should delete config file if no other properties remain" time="0.000146167">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; clearApiKey &gt; should warn on error" time="0.000259541">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; getDefaultModel &gt; should return null when config file does not exist" time="0.000118541">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; getDefaultModel &gt; should return default model from config" time="0.000100292">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; getDefaultModel &gt; should return null when defaultModel is not in config" time="0.0000985">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; getDefaultModel &gt; should return null and warn on error" time="0.000178416">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; setDefaultModel &gt; should create config directory if it does not exist" time="0.000198209">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; setDefaultModel &gt; should create new config file with default model" time="0.000127792">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; setDefaultModel &gt; should update existing config with default model" time="0.000126958">
        </testcase>
        <testcase classname="src/utils/local-settings.test.ts" name="ConfigManager &gt; setDefaultModel &gt; should throw error on write failure" time="0.000168375">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/markdown.test.ts" timestamp="2025-08-11T18:03:48.311Z" hostname="Emmanuels-MacBook-Air.local" tests="22" failures="0" errors="0" skipped="0" time="0.004526959">
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseMarkdown &gt; should parse plain text" time="0.00126175">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseMarkdown &gt; should parse headings with correct levels" time="0.00024175">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseMarkdown &gt; should parse code blocks" time="0.000080583">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseMarkdown &gt; should parse mixed content with inline code" time="0.000065875">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseMarkdown &gt; should parse mixed content with bold text" time="0.000061584">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseMarkdown &gt; should parse mixed content with italic text" time="0.000058333">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseMarkdown &gt; should handle empty lines" time="0.000067417">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseMarkdown &gt; should handle complex markdown document" time="0.00072675">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseMarkdown &gt; should handle code block at end of content" time="0.0000905">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseMarkdown &gt; should handle unclosed code block" time="0.000062709">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should parse plain text" time="0.00016375">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should parse inline code" time="0.000130458">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should parse bold text" time="0.000070375">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should parse italic text" time="0.000071625">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should parse multiple inline elements" time="0.000089333">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should handle text starting with inline element" time="0.000058625">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should handle text ending with inline element" time="0.000054375">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should handle adjacent inline elements" time="0.000054333">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should handle empty string" time="0.000045">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should prioritize inline code over other elements" time="0.00004925">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should handle unmatched markdown symbols" time="0.000047667">
        </testcase>
        <testcase classname="src/utils/markdown.test.ts" name="markdown &gt; parseInlineElements &gt; should handle unmatched backticks" time="0.000046666">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/definitions/clear.test.ts" timestamp="2025-08-11T18:03:48.312Z" hostname="Emmanuels-MacBook-Air.local" tests="7" failures="0" errors="0" skipped="0" time="0.005048916">
        <testcase classname="src/commands/definitions/clear.test.ts" name="clearCommand &gt; should have correct command properties" time="0.000910834">
        </testcase>
        <testcase classname="src/commands/definitions/clear.test.ts" name="clearCommand &gt; should call clearHistory and add confirmation message" time="0.001831708">
        </testcase>
        <testcase classname="src/commands/definitions/clear.test.ts" name="clearCommand &gt; should call clearHistory before adding message" time="0.000194125">
        </testcase>
        <testcase classname="src/commands/definitions/clear.test.ts" name="clearCommand &gt; should not call other context methods" time="0.000261667">
        </testcase>
        <testcase classname="src/commands/definitions/clear.test.ts" name="clearCommand &gt; should handle context destructuring correctly" time="0.000231042">
        </testcase>
        <testcase classname="src/commands/definitions/clear.test.ts" name="clearCommand &gt; should work with minimal context" time="0.000611292">
        </testcase>
        <testcase classname="src/commands/definitions/clear.test.ts" name="clearCommand &gt; should add system message with correct content" time="0.000118833">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/definitions/help.test.ts" timestamp="2025-08-11T18:03:48.312Z" hostname="Emmanuels-MacBook-Air.local" tests="7" failures="0" errors="0" skipped="0" time="0.008502417">
        <testcase classname="src/commands/definitions/help.test.ts" name="helpCommand &gt; should have correct command properties" time="0.002359167">
        </testcase>
        <testcase classname="src/commands/definitions/help.test.ts" name="helpCommand &gt; should add system message with help content" time="0.002513458">
        </testcase>
        <testcase classname="src/commands/definitions/help.test.ts" name="helpCommand &gt; should include all available commands in help message" time="0.000501667">
        </testcase>
        <testcase classname="src/commands/definitions/help.test.ts" name="helpCommand &gt; should include navigation instructions" time="0.000697791">
        </testcase>
        <testcase classname="src/commands/definitions/help.test.ts" name="helpCommand &gt; should include keyboard shortcuts" time="0.0002265">
        </testcase>
        <testcase classname="src/commands/definitions/help.test.ts" name="helpCommand &gt; should include application description" time="0.000136625">
        </testcase>
        <testcase classname="src/commands/definitions/help.test.ts" name="helpCommand &gt; should not call other context methods" time="0.000338667">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/definitions/login.test.ts" timestamp="2025-08-11T18:03:48.313Z" hostname="Emmanuels-MacBook-Air.local" tests="5" failures="0" errors="0" skipped="0" time="0.004682333">
        <testcase classname="src/commands/definitions/login.test.ts" name="loginCommand &gt; should have correct command properties" time="0.000951084">
        </testcase>
        <testcase classname="src/commands/definitions/login.test.ts" name="loginCommand &gt; should call setShowLogin with true" time="0.001430541">
        </testcase>
        <testcase classname="src/commands/definitions/login.test.ts" name="loginCommand &gt; should not call other context methods" time="0.00026325">
        </testcase>
        <testcase classname="src/commands/definitions/login.test.ts" name="loginCommand &gt; should work with minimal context" time="0.00054925">
        </testcase>
        <testcase classname="src/commands/definitions/login.test.ts" name="loginCommand &gt; should handle context destructuring correctly" time="0.000137042">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/definitions/model.test.ts" timestamp="2025-08-11T18:03:48.313Z" hostname="Emmanuels-MacBook-Air.local" tests="8" failures="0" errors="0" skipped="0" time="0.0109775">
        <testcase classname="src/commands/definitions/model.test.ts" name="modelCommand &gt; should have correct command properties" time="0.002670875">
        </testcase>
        <testcase classname="src/commands/definitions/model.test.ts" name="modelCommand &gt; should call setShowModelSelector with true when available" time="0.004222209">
        </testcase>
        <testcase classname="src/commands/definitions/model.test.ts" name="modelCommand &gt; should not crash when setShowModelSelector is undefined" time="0.001450167">
        </testcase>
        <testcase classname="src/commands/definitions/model.test.ts" name="modelCommand &gt; should not call setShowModelSelector when it is undefined" time="0.000244709">
        </testcase>
        <testcase classname="src/commands/definitions/model.test.ts" name="modelCommand &gt; should not call other context methods when setShowModelSelector is available" time="0.000193">
        </testcase>
        <testcase classname="src/commands/definitions/model.test.ts" name="modelCommand &gt; should handle context destructuring correctly" time="0.000144">
        </testcase>
        <testcase classname="src/commands/definitions/model.test.ts" name="modelCommand &gt; should check for setShowModelSelector existence before calling" time="0.000127958">
        </testcase>
        <testcase classname="src/commands/definitions/model.test.ts" name="modelCommand &gt; should work correctly with all optional properties present" time="0.000189459">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/definitions/reasoning.test.ts" timestamp="2025-08-11T18:03:48.314Z" hostname="Emmanuels-MacBook-Air.local" tests="11" failures="0" errors="0" skipped="0" time="0.005438959">
        <testcase classname="src/commands/definitions/reasoning.test.ts" name="reasoningCommand &gt; should have correct command properties" time="0.0009045">
        </testcase>
        <testcase classname="src/commands/definitions/reasoning.test.ts" name="reasoningCommand &gt; should toggle reasoning and add enabled message when showReasoning is false" time="0.001755584">
        </testcase>
        <testcase classname="src/commands/definitions/reasoning.test.ts" name="reasoningCommand &gt; should toggle reasoning and add disabled message when showReasoning is true" time="0.000205042">
        </testcase>
        <testcase classname="src/commands/definitions/reasoning.test.ts" name="reasoningCommand &gt; should show not available message when toggleReasoning is undefined" time="0.000147166">
        </testcase>
        <testcase classname="src/commands/definitions/reasoning.test.ts" name="reasoningCommand &gt; should show not available message when toggleReasoning is null" time="0.000120209">
        </testcase>
        <testcase classname="src/commands/definitions/reasoning.test.ts" name="reasoningCommand &gt; should handle showReasoning being undefined when toggleReasoning exists" time="0.0001795">
        </testcase>
        <testcase classname="src/commands/definitions/reasoning.test.ts" name="reasoningCommand &gt; should not call other context methods when toggleReasoning is available" time="0.000202291">
        </testcase>
        <testcase classname="src/commands/definitions/reasoning.test.ts" name="reasoningCommand &gt; should not call other context methods when toggleReasoning is unavailable" time="0.000144208">
        </testcase>
        <testcase classname="src/commands/definitions/reasoning.test.ts" name="reasoningCommand &gt; should handle context destructuring correctly" time="0.000147583">
        </testcase>
        <testcase classname="src/commands/definitions/reasoning.test.ts" name="reasoningCommand &gt; should work with minimal context when toggleReasoning is unavailable" time="0.000577">
        </testcase>
        <testcase classname="src/commands/definitions/reasoning.test.ts" name="reasoningCommand &gt; should correctly invert showReasoning state in message" time="0.000207916">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useAgent.test.ts" timestamp="2025-08-11T18:03:48.314Z" hostname="Emmanuels-MacBook-Air.local" tests="32" failures="9" errors="0" skipped="0" time="0.099441458">
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; initial state &gt; should initialize with correct default values" time="0.011600208">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; initial state &gt; should provide all required methods" time="0.00087125">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; sendMessage &gt; should add user message and call agent" time="0.002892333">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; sendMessage &gt; should not send message if already processing" time="0.001053291">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; sendMessage &gt; should handle chat errors gracefully" time="0.005373458">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; sendMessage &gt; should handle API errors with status and error details" time="0.001253834">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; sendMessage &gt; should ignore abort errors" time="0.002581167">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool execution callbacks &gt; should handle onThinkingText callback" time="0.006558584">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
            <failure message="expected undefined to be defined" type="AssertionError">
AssertionError: expected undefined to be defined
 ❯ src/ui/hooks/useAgent.test.ts:213:32
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool execution callbacks &gt; should handle onFinalMessage callback" time="0.001434291">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
            <failure message="expected undefined to be defined" type="AssertionError">
AssertionError: expected undefined to be defined
 ❯ src/ui/hooks/useAgent.test.ts:228:32
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool execution callbacks &gt; should handle onToolStart callback" time="0.0017">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
            <failure message="expected null not to be null" type="AssertionError">
AssertionError: expected null not to be null
 ❯ src/ui/hooks/useAgent.test.ts:242:55
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool execution callbacks &gt; should handle onToolEnd callback with success" time="0.009239458">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
            <failure message="expected undefined to be &apos;✓ read_file completed successfully&apos; // Object.is equality" type="AssertionError">
AssertionError: expected undefined to be &apos;✓ read_file completed successfully&apos; // Object.is equality

- Expected: 
&quot;✓ read_file completed successfully&quot;

+ Received: 
undefined

 ❯ src/ui/hooks/useAgent.test.ts:274:39
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool execution callbacks &gt; should handle onToolEnd callback with failure" time="0.00148225">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
            <failure message="expected undefined to be &apos;🔴 read_file failed: File not found&apos; // Object.is equality" type="AssertionError">
AssertionError: expected undefined to be &apos;🔴 read_file failed: File not found&apos; // Object.is equality

- Expected: 
&quot;🔴 read_file failed: File not found&quot;

+ Received: 
undefined

 ❯ src/ui/hooks/useAgent.test.ts:300:39
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool execution callbacks &gt; should handle onToolEnd callback with user rejection" time="0.01716975">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
            <failure message="expected undefined to be &apos;🚫 delete_file rejected by user&apos; // Object.is equality" type="AssertionError">
AssertionError: expected undefined to be &apos;🚫 delete_file rejected by user&apos; // Object.is equality

- Expected: 
&quot;🚫 delete_file rejected by user&quot;

+ Received: 
undefined

 ❯ src/ui/hooks/useAgent.test.ts:326:39
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool execution callbacks &gt; should handle onApiUsage callback" time="0.00277">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool execution callbacks &gt; should handle onToolApproval callback" time="0.002738292">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
            <failure message="expected null not to be null" type="AssertionError">
AssertionError: expected null not to be null
 ❯ src/ui/hooks/useAgent.test.ts:362:50
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool execution callbacks &gt; should handle onMaxIterations callback" time="0.01553375">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
            <failure message="expected null not to be null" type="AssertionError">
AssertionError: expected null not to be null
 ❯ src/ui/hooks/useAgent.test.ts:388:55
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool approval &gt; should approve tool execution" time="0.001432292">
            <failure message="result.current.setPendingApproval is not a function" type="TypeError">
TypeError: result.current.setPendingApproval is not a function
 ❯ src/ui/hooks/useAgent.test.ts:417:33
 ❯ node_modules/@testing-library/react/dist/act-compat.js:48:24
 ❯ process.env.NODE_ENV.exports.act node_modules/react/cjs/react.development.js:790:22
 ❯ Proxy.&lt;anonymous&gt; node_modules/@testing-library/react/dist/act-compat.js:47:25
 ❯ src/ui/hooks/useAgent.test.ts:416:7
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool approval &gt; should reject tool execution" time="0.000838209">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; utility functions &gt; should set API key on agent" time="0.000577917">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; utility functions &gt; should toggle auto approve" time="0.000663542">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; utility functions &gt; should clear history" time="0.000665583">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; utility functions &gt; should interrupt request" time="0.000604083">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; utility functions &gt; should toggle reasoning display" time="0.000552542">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; message management &gt; should add message with generated id and timestamp" time="0.000658833">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; message management &gt; should add message with reasoning" time="0.000505708">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; message management &gt; should generate unique message ids" time="0.000521708">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool execution states &gt; should identify tools that need approval" time="0.000918">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; tool execution states &gt; should handle tool execution status changes" time="0.000844458">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; edge cases &gt; should handle empty message content" time="0.000593">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; edge cases &gt; should handle multiple rapid message additions" time="0.000840125">
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; edge cases &gt; should handle callback functions being undefined" time="0.002151334">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useAgent.test.ts" name="useAgent &gt; edge cases &gt; should handle agent methods throwing errors" time="0.001452291">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useTokenMetrics.test.ts" timestamp="2025-08-11T18:03:48.319Z" hostname="Emmanuels-MacBook-Air.local" tests="33" failures="0" errors="0" skipped="0" time="0.064569875">
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; initial state &gt; should initialize with default values" time="0.01513825">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; initial state &gt; should provide all required methods" time="0.000825917">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; startRequest &gt; should start a new request with correct initial state" time="0.002463875">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; startRequest &gt; should reset previous request data" time="0.003583">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; startRequest &gt; should set start time to current time" time="0.000984417">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; addApiTokens &gt; should accumulate completion tokens" time="0.002605833">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; addApiTokens &gt; should handle zero token usage" time="0.001354916">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; addApiTokens &gt; should work without starting a request" time="0.000814292">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; addApiTokens &gt; should only use completion_tokens from usage" time="0.001106209">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; pauseMetrics &gt; should pause metrics correctly" time="0.001219583">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; pauseMetrics &gt; should not pause if already paused" time="0.001129625">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; pauseMetrics &gt; should work without starting a request" time="0.001639416">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; pauseMetrics &gt; should set pause start time" time="0.000780875">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; resumeMetrics &gt; should resume from pause correctly" time="0.001372209">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; resumeMetrics &gt; should not resume if not paused" time="0.000574334">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; resumeMetrics &gt; should accumulate multiple pause durations" time="0.000601834">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; resumeMetrics &gt; should calculate pause duration correctly" time="0.001787583">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; completeRequest &gt; should complete request correctly" time="0.000730667">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; completeRequest &gt; should handle completion while paused" time="0.000581">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; completeRequest &gt; should work without starting a request" time="0.00743375">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; completeRequest &gt; should set end time to current time" time="0.001669417">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; completeRequest &gt; should handle multiple completions" time="0.001953417">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; resetMetrics &gt; should reset all metrics to initial state" time="0.00192325">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; resetMetrics &gt; should reset while request is active" time="0.000906375">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; resetMetrics &gt; should reset while paused" time="0.000600375">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; complex workflows &gt; should handle full request lifecycle" time="0.001004625">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; complex workflows &gt; should handle multiple pause/resume cycles" time="0.000677917">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; complex workflows &gt; should handle token accumulation across pauses" time="0.001432334">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; complex workflows &gt; should handle rapid state changes" time="0.001014292">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; edge cases &gt; should handle zero duration pauses" time="0.000541417">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; edge cases &gt; should handle negative token values" time="0.00045275">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; edge cases &gt; should handle very large token values" time="0.000420625">
        </testcase>
        <testcase classname="src/ui/hooks/useTokenMetrics.test.ts" name="useTokenMetrics &gt; edge cases &gt; should maintain state consistency across many operations" time="0.003534708">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/core/Chat.test.tsx" timestamp="2025-08-11T18:03:48.321Z" hostname="Emmanuels-MacBook-Air.local" tests="16" failures="4" errors="0" skipped="0" time="1.120235417">
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; rendering &gt; should render all core components" time="0.021259084">
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; rendering &gt; should show token metrics when active" time="0.001893584">
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; rendering &gt; should show pending approval when tool needs approval" time="0.0029895">
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; rendering &gt; should show login when showLogin is true" time="0.001403709">
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; rendering &gt; should show max iterations dialog when pending" time="0.00140575">
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; keyboard shortcuts &gt; should exit on Ctrl+C" time="0.019998709">
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; keyboard shortcuts &gt; should toggle auto-approve on Shift+Tab" time="0.021961">
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; keyboard shortcuts &gt; should handle escape key for pending approval" time="0.008706792">
            <failure message="expected &quot;spy&quot; to be called with arguments: [ false ][90m

Received: 

[1m  1st spy call:

[22m[2m  [[22m
[2m    false,[22m
[31m+   undefined,[90m
[2m  ][22m
[39m[90m

Number of calls: [1m1[22m
[39m" type="AssertionError">
AssertionError: expected &quot;spy&quot; to be called with arguments: [ false ]

Received: 

  1st spy call:

  [
    false,
+   undefined,
  ]


Number of calls: 1

 ❯ src/ui/components/core/Chat.test.tsx:228:56
            </failure>
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; keyboard shortcuts &gt; should interrupt processing on escape when processing" time="0.002784667">
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; message handling &gt; should send messages through agent hook" time="1.012605417">
            <failure message="expected &quot;spy&quot; to be called with arguments: [ &apos;test message&apos; ][90m

Number of calls: [1m0[22m
[39m

Ignored nodes: comments, script, style
[36m&lt;html&gt;[39m
  [36m&lt;head /&gt;[39m
  [36m&lt;body&gt;[39m
    [36m&lt;div&gt;[39m
      [36m&lt;div[39m
        [33mdata-testid[39m=[32m&quot;box&quot;[39m
      [36m&gt;[39m
        [36m&lt;div[39m
          [33mdata-testid[39m=[32m&quot;box&quot;[39m
        [36m&gt;[39m
          [36m&lt;div[39m
            [33mdata-testid[39m=[32m&quot;message-history&quot;[39m
          [36m&gt;[39m
            [0mMessageHistory[0m
          [36m&lt;/div&gt;[39m
        [36m&lt;/div&gt;[39m
        [36m&lt;div[39m
          [33mdata-testid[39m=[32m&quot;token-metrics&quot;[39m
        [36m&gt;[39m
          [0mTokenMetrics[0m
        [36m&lt;/div&gt;[39m
        [36m&lt;div[39m
          [33mdata-testid[39m=[32m&quot;box&quot;[39m
        [36m&gt;[39m
          [36m&lt;div[39m
            [33mdata-testid[39m=[32m&quot;message-input&quot;[39m
          [36m&gt;[39m
            [36m&lt;input[39m
              [33mvalue[39m=[32m&quot;&quot;[39m
            [36m/&gt;[39m
            [36m&lt;button&gt;[39m
              [0mSend[0m
            [36m&lt;/button&gt;[39m
          [36m&lt;/div&gt;[39m
        [36m&lt;/div&gt;[39m
        [36m&lt;div[39m
          [33mdata-testid[39m=[32m&quot;box&quot;[39m
        [36m&gt;[39m
          [36m&lt;div[39m
            [33mdata-testid[39m=[32m&quot;box&quot;[39m
          [36m&gt;[39m
            [36m&lt;span[39m
              [33mdata-testid[39m=[32m&quot;text&quot;[39m
            [36m/&gt;[39m
          [36m&lt;/div&gt;[39m
          [36m&lt;div[39m
            [33mdata-testid[39m=[32m&quot;box&quot;[39m
          [36m&gt;[39m
            [36m&lt;span[39m
              [33mdata-testid[39m=[32m&quot;text&quot;[39m
            [36m/&gt;[39m
          [36m&lt;/div&gt;[39m
        [36m&lt;/div&gt;[39m
      [36m&lt;/div&gt;[39m
    [36m&lt;/div&gt;[39m
  [36m&lt;/body&gt;[39m
[36m&lt;/html&gt;[39m" type="AssertionError">
AssertionError: expected &quot;spy&quot; to be called with arguments: [ &apos;test message&apos; ]

Number of calls: 0


Ignored nodes: comments, script, style
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    &lt;div&gt;
      &lt;div
        data-testid=&quot;box&quot;
      &gt;
        &lt;div
          data-testid=&quot;box&quot;
        &gt;
          &lt;div
            data-testid=&quot;message-history&quot;
          &gt;
            MessageHistory
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div
          data-testid=&quot;token-metrics&quot;
        &gt;
          TokenMetrics
        &lt;/div&gt;
        &lt;div
          data-testid=&quot;box&quot;
        &gt;
          &lt;div
            data-testid=&quot;message-input&quot;
          &gt;
            &lt;input
              value=&quot;&quot;
            /&gt;
            &lt;button&gt;
              Send
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div
          data-testid=&quot;box&quot;
        &gt;
          &lt;div
            data-testid=&quot;box&quot;
          &gt;
            &lt;span
              data-testid=&quot;text&quot;
            /&gt;
          &lt;/div&gt;
          &lt;div
            data-testid=&quot;box&quot;
          &gt;
            &lt;span
              data-testid=&quot;text&quot;
            /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
 ❯ src/ui/components/core/Chat.test.tsx:258:51
 ❯ runWithExpensiveErrorDiagnosticsDisabled node_modules/@testing-library/dom/dist/config.js:47:12
 ❯ checkCallback node_modules/@testing-library/dom/dist/wait-for.js:124:77
 ❯ Timeout.checkRealTimersCallback node_modules/@testing-library/dom/dist/wait-for.js:118:16
            </failure>
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; message handling &gt; should handle slash commands" time="0.001725125">
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; state management &gt; should hide input when processing" time="0.003028708">
            <failure message="expected null to be truthy" type="AssertionError">
AssertionError: expected null to be truthy

- Expected: 
true

+ Received: 
null

 ❯ src/ui/components/core/Chat.test.tsx:286:21
            </failure>
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; state management &gt; should hide input when pending approval" time="0.006764125">
            <failure message="expected null to be truthy" type="AssertionError">
AssertionError: expected null to be truthy

- Expected: 
true

+ Received: 
null

 ❯ src/ui/components/core/Chat.test.tsx:296:21
            </failure>
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; tool approval &gt; should approve tool execution" time="0.005115708">
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; tool approval &gt; should reject tool execution" time="0.005051209">
        </testcase>
        <testcase classname="src/ui/components/core/Chat.test.tsx" name="Chat &gt; metrics integration &gt; should pass metrics callbacks to useAgent" time="0.002204041">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/core/MessageHistory.test.tsx" timestamp="2025-08-11T18:03:48.322Z" hostname="Emmanuels-MacBook-Air.local" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/ui/components/core/MessageHistory.test.tsx" name="src/ui/components/core/MessageHistory.test.tsx" time="0">
            <failure message="Transform failed with 1 error:
/Users/e/dev/github.com/cloudbring/groq-code-cli/src/ui/components/core/MessageHistory.test.tsx:212:63: ERROR: &quot;await&quot; can only be used inside an &quot;async&quot; function" type="Error">
Error: Transform failed with 1 error:
/Users/e/dev/github.com/cloudbring/groq-code-cli/src/ui/components/core/MessageHistory.test.tsx:212:63: ERROR: &quot;await&quot; can only be used inside an &quot;async&quot; function
  Plugin: vite:esbuild
  File: /Users/e/dev/github.com/cloudbring/groq-code-cli/src/ui/components/core/MessageHistory.test.tsx:212:63
  
  &quot;await&quot; can only be used inside an &quot;async&quot; function
  210 |      beforeEach(() =&gt; {
  211 |        // Reset markdown mocks for these tests
  212 |        const { parseMarkdown, parseInlineElements } = vi.mocked(await import(&apos;../../../utils/markdown.js&apos;));
      |                                                                 ^
  213 |        
  214 |        parseMarkdown.mockImplementation((content) =&gt; {
  
 ❯ failureErrorWithLog node_modules/esbuild/lib/main.js:1467:15
 ❯ node_modules/esbuild/lib/main.js:736:50
 ❯ responseCallbacks.&lt;computed&gt; node_modules/esbuild/lib/main.js:603:9
 ❯ handleIncomingPacket node_modules/esbuild/lib/main.js:658:12
 ❯ Socket.readFromStdout node_modules/esbuild/lib/main.js:581:7
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/core/MessageInput.test.tsx" timestamp="2025-08-11T18:03:48.323Z" hostname="Emmanuels-MacBook-Air.local" tests="26" failures="0" errors="0" skipped="0" time="0.133147709">
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; rendering &gt; should render with placeholder when value is empty" time="0.0646045">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; rendering &gt; should render with custom placeholder" time="0.003940416">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; rendering &gt; should render value when provided" time="0.003208">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; rendering &gt; should show slash command suggestions when input starts with /" time="0.001827417">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; rendering &gt; should not show slash command suggestions for regular input" time="0.001996709">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; input handling &gt; should handle character input" time="0.003169209">
            <system-err>
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; input handling &gt; should handle character input at cursor position" time="0.002810625">
            <system-err>
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; input handling &gt; should handle backspace" time="0.001542959">
            <system-err>
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; input handling &gt; should handle delete key" time="0.004863667">
            <system-err>
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; input handling &gt; should handle enter key" time="0.003410708">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; input handling &gt; should handle enter key with slash command" time="0.0015945">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; input handling &gt; should ignore meta key combinations" time="0.00194475">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; input handling &gt; should ignore ctrl key combinations" time="0.001313708">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; input handling &gt; should replace newlines with spaces" time="0.003084958">
            <system-err>
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; cursor navigation &gt; should handle left arrow" time="0.001078292">
            <system-err>
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; cursor navigation &gt; should handle right arrow" time="0.0010875">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; cursor navigation &gt; should handle up arrow for slash commands" time="0.001723125">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; cursor navigation &gt; should handle down arrow for slash commands" time="0.001978958">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; message history navigation &gt; should navigate to previous message with up arrow at cursor position 0" time="0.003470792">
            <system-err>
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; message history navigation &gt; should navigate through history with multiple up arrows" time="0.002708917">
            <system-err>
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; message history navigation &gt; should navigate back with down arrow" time="0.003681583">
            <system-err>
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; message history navigation &gt; should preserve draft message when navigating history" time="0.003165">
            <system-err>
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; edge cases &gt; should handle empty value submission" time="0.002934125">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; edge cases &gt; should handle backspace at cursor position 0" time="0.001632208">
            <system-err>
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MessageInput inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; edge cases &gt; should handle value changes from parent" time="0.003108708">
        </testcase>
        <testcase classname="src/ui/components/core/MessageInput.test.tsx" name="MessageInput &gt; edge cases &gt; should reset cursor when value is cleared" time="0.005067458">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/display/DiffPreview.test.tsx" timestamp="2025-08-11T18:03:48.325Z" hostname="Emmanuels-MacBook-Air.local" tests="25" failures="0" errors="0" skipped="0" time="0.283453667">
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; rendering states &gt; should render loading state initially" time="0.034679292">
            <system-err>
An update to DiffPreview inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to DiffPreview inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; rendering states &gt; should render error state for missing file path" time="0.015558417">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; rendering states &gt; should render read-before-edit error for non-historical edits" time="0.010380291">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; rendering states &gt; should render no changes state when diff is empty" time="0.017493833">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; edit_file operations &gt; should generate diff for string-based edit with old_text and new_text" time="0.010481625">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; edit_file operations &gt; should handle replace_all option" time="0.004890791">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; edit_file operations &gt; should handle case where old_text is not found in current file" time="0.004452125">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; edit_file operations &gt; should reconstruct original when new_text is found in current file" time="0.005919042">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; create_file operations &gt; should generate diff for create_file with content" time="0.009337083">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; historical edits &gt; should generate synthetic diff for historical edit_file" time="0.014867625">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; historical edits &gt; should generate synthetic diff for historical create_file" time="0.009376125">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; historical edits &gt; should handle historical edit with missing parameters" time="0.004572875">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; historical edits &gt; should not validate read-before-edit for historical edits" time="0.008880917">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; diff rendering &gt; should render diff lines with proper colors" time="0.00496325">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; diff rendering &gt; should handle multiple diff chunks" time="0.00866425">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; error handling &gt; should handle file read errors gracefully" time="0.009651917">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; error handling &gt; should handle diff generation errors" time="0.008101958">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; LCS algorithm &gt; should generate proper unified diff with context" time="0.010206708">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; LCS algorithm &gt; should handle empty files" time="0.005898708">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; LCS algorithm &gt; should handle identical content" time="0.0059585">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; component updates &gt; should regenerate diff when toolName changes" time="0.006071375">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; component updates &gt; should regenerate diff when toolArgs change" time="0.003242417">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; edge cases &gt; should handle very long files" time="0.054036334">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; edge cases &gt; should handle binary-like content" time="0.007214792">
        </testcase>
        <testcase classname="src/ui/components/display/DiffPreview.test.tsx" name="DiffPreview &gt; edge cases &gt; should handle files with only whitespace" time="0.005221708">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/display/TokenMetrics.test.tsx" timestamp="2025-08-11T18:03:48.326Z" hostname="Emmanuels-MacBook-Air.local" tests="12" failures="0" errors="0" skipped="0" time="0.122305125">
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; rendering &gt; should not render when inactive and no tokens" time="0.010224125">
        </testcase>
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; rendering &gt; should render when active" time="0.011809292">
        </testcase>
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; rendering &gt; should render when inactive but has tokens" time="0.018106584">
        </testcase>
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; rendering &gt; should show paused status" time="0.01655425">
        </testcase>
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; time tracking &gt; should update time every 100ms when active" time="0.024990584">
            <system-err>
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; time tracking &gt; should not update time when paused" time="0.00262625">
        </testcase>
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; time tracking &gt; should account for paused time" time="0.021637792">
        </testcase>
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; time tracking &gt; should show final time when completed" time="0.001761167">
        </testcase>
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; loading messages &gt; should cycle through loading messages" time="0.006372667">
            <system-err>
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to TokenMetrics inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; loading messages &gt; should reset loading message index when becoming active" time="0.001894959">
        </testcase>
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; edge cases &gt; should handle null startTime" time="0.001387375">
        </testcase>
        <testcase classname="src/ui/components/display/TokenMetrics.test.tsx" name="TokenMetrics &gt; edge cases &gt; should handle transition from active to inactive" time="0.002737334">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/display/ToolHistoryItem.test.tsx" timestamp="2025-08-11T18:03:48.327Z" hostname="Emmanuels-MacBook-Air.local" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/ui/components/display/ToolHistoryItem.test.tsx" name="src/ui/components/display/ToolHistoryItem.test.tsx" time="0">
            <failure message="Cannot find module &apos;/Users/e/dev/github.com/cloudbring/groq-code-cli/src/utils/file-ops.js&apos; imported from /Users/e/dev/github.com/cloudbring/groq-code-cli/src/tools/tools.ts" type="Error">
Error: Cannot find module &apos;/Users/e/dev/github.com/cloudbring/groq-code-cli/src/utils/file-ops.js&apos; imported from /Users/e/dev/github.com/cloudbring/groq-code-cli/src/tools/tools.ts
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Serialized Error: { code: &apos;ERR_MODULE_NOT_FOUND&apos;, url: &apos;file:///Users/e/dev/github.com/cloudbring/groq-code-cli/src/utils/file-ops.js&apos; }
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/input-overlays/Login.test.tsx" timestamp="2025-08-11T18:03:48.327Z" hostname="Emmanuels-MacBook-Air.local" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/ui/components/input-overlays/Login.test.tsx" name="src/ui/components/input-overlays/Login.test.tsx" time="0">
            <failure message="[vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock" type="Error">
Error: [vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock
 ❯ src/ui/components/input-overlays/Login.test.tsx:5:1

Caused by: Caused by: ReferenceError: Cannot access &apos;MockLogin&apos; before initialization
 ❯ src/ui/components/input-overlays/Login.test.tsx:52:12
 ❯ src/ui/components/input-overlays/Login.test.tsx:5:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" timestamp="2025-08-11T18:03:48.328Z" hostname="Emmanuels-MacBook-Air.local" tests="24" failures="0" errors="0" skipped="0" time="0.1584145">
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; rendering &gt; should render header and message" time="0.021929791">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; rendering &gt; should render both options with proper initial selection" time="0.013633291">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; rendering &gt; should display iteration count correctly" time="0.032843792">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; keyboard navigation &gt; should handle up arrow to move to first option" time="0.006760542">
            <system-err>
An update to MaxIterationsContinue inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MaxIterationsContinue inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; keyboard navigation &gt; should handle down arrow to move to second option" time="0.002297542">
            <system-err>
An update to MaxIterationsContinue inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; keyboard navigation &gt; should not move above first option" time="0.005060667">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; keyboard navigation &gt; should not move below second option" time="0.008233041">
            <system-err>
An update to MaxIterationsContinue inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MaxIterationsContinue inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; option selection &gt; should call onContinue when return is pressed on first option" time="0.007836958">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; option selection &gt; should call onStop when return is pressed on second option" time="0.006236334">
            <system-err>
An update to MaxIterationsContinue inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; option selection &gt; should call onStop when escape is pressed" time="0.006044333">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; component state management &gt; should reset selection when maxIterations changes" time="0.006824833">
            <system-err>
An update to MaxIterationsContinue inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; component state management &gt; should handle prop changes correctly" time="0.003366083">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; visual states &gt; should show correct colors for first option when selected" time="0.002751542">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; visual states &gt; should show correct colors for second option when selected" time="0.006421208">
            <system-err>
An update to MaxIterationsContinue inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; visual states &gt; should show correct colors for unselected options" time="0.004910083">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; accessibility and user experience &gt; should provide clear visual indication of selected option" time="0.001930083">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; accessibility and user experience &gt; should show escape hint in the stop option text" time="0.004079292">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; accessibility and user experience &gt; should display helpful context about the situation" time="0.001833083">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; edge cases &gt; should handle zero iterations" time="0.003062333">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; edge cases &gt; should handle very large iteration counts" time="0.002745625">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; edge cases &gt; should handle multiple rapid key presses" time="0.001476667">
            <system-err>
An update to MaxIterationsContinue inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MaxIterationsContinue inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to MaxIterationsContinue inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; edge cases &gt; should ignore unknown key presses" time="0.001481791">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; component lifecycle &gt; should handle multiple re-renders" time="0.003451459">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/MaxIterationsContinue.test.tsx" name="MaxIterationsContinue &gt; component lifecycle &gt; should properly clean up useInput on unmount" time="0.001550208">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/input-overlays/ModelSelector.test.tsx" timestamp="2025-08-11T18:03:48.329Z" hostname="Emmanuels-MacBook-Air.local" tests="30" failures="0" errors="0" skipped="0" time="0.20434275">
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; rendering &gt; should render model selector with title" time="0.0189415">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; rendering &gt; should render all available models" time="0.003126291">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; rendering &gt; should show pricing information link" time="0.016285583">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; rendering &gt; should highlight first model by default" time="0.002431125">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; rendering &gt; should show current model when provided" time="0.008216292">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; rendering &gt; should select current model when provided" time="0.00221125">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; rendering &gt; should show descriptions for models that have them" time="0.002057834">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; navigation &gt; should handle up arrow navigation" time="0.001983875">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; navigation &gt; should handle down arrow navigation" time="0.012629958">
            <system-err>
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; navigation &gt; should not go above first model" time="0.009164625">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; navigation &gt; should not go below last model" time="0.0022815">
            <system-err>
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; navigation &gt; should wrap navigation correctly at boundaries" time="0.006277375">
            <system-err>
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; selection and submission &gt; should handle enter key to submit" time="0.006135083">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; selection and submission &gt; should submit correct model when selection changes" time="0.015695459">
            <system-err>
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; selection and submission &gt; should handle escape key to cancel" time="0.008762708">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; selection and submission &gt; should handle ctrl+c to cancel" time="0.001703209">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; model information &gt; should display model descriptions when available" time="0.004071958">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; model information &gt; should handle models without descriptions" time="0.001950667">
            <system-err>
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; model information &gt; should show current model indicator" time="0.00196975">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; initialization &gt; should initialize with first model when no current model provided" time="0.005246041">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; initialization &gt; should initialize with current model when provided" time="0.001701084">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; initialization &gt; should fallback to first model for unknown current model" time="0.008455417">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; visual feedback &gt; should show selection indicator" time="0.013531333">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; visual feedback &gt; should have proper visual hierarchy" time="0.014326458">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; visual feedback &gt; should warn about chat clearing" time="0.003082166">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; accessibility &gt; should provide clear instructions" time="0.008209083">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; accessibility &gt; should have underlined pricing link" time="0.008600209">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; edge cases &gt; should handle empty model list gracefully" time="0.001420833">
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; edge cases &gt; should handle rapid navigation" time="0.001902708">
            <system-err>
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to ModelSelector inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/input-overlays/ModelSelector.test.tsx" name="ModelSelector &gt; edge cases &gt; should handle multiple renders" time="0.010469167">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/input-overlays/PendingToolApproval.test.tsx" timestamp="2025-08-11T18:03:48.331Z" hostname="Emmanuels-MacBook-Air.local" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/ui/components/input-overlays/PendingToolApproval.test.tsx" name="src/ui/components/input-overlays/PendingToolApproval.test.tsx" time="0">
            <failure message="Cannot find module &apos;../../../tools/tools.js&apos;
Require stack:
- /Users/e/dev/github.com/cloudbring/groq-code-cli/src/ui/components/input-overlays/PendingToolApproval.test.tsx" type="Error">
Error: Cannot find module &apos;../../../tools/tools.js&apos;
Require stack:
- /Users/e/dev/github.com/cloudbring/groq-code-cli/src/ui/components/input-overlays/PendingToolApproval.test.tsx
 ❯ src/ui/components/input-overlays/PendingToolApproval.test.tsx:65:42

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Serialized Error: { code: &apos;MODULE_NOT_FOUND&apos;, requireStack: [ &apos;/Users/e/dev/github.com/cloudbring/groq-code-cli/src/ui/components/input-overlays/PendingToolApproval.test.tsx&apos; ] }
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/input-overlays/SlashCommandSuggestions.test.tsx" timestamp="2025-08-11T18:03:48.332Z" hostname="Emmanuels-MacBook-Air.local" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/ui/components/input-overlays/SlashCommandSuggestions.test.tsx" name="src/ui/components/input-overlays/SlashCommandSuggestions.test.tsx" time="0">
            <failure message="[vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock" type="Error">
Error: [vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock
 ❯ src/ui/components/input-overlays/SlashCommandSuggestions.tsx:3:1

Caused by: Caused by: ReferenceError: Cannot access &apos;mockGetAvailableCommands&apos; before initialization
 ❯ src/ui/components/input-overlays/SlashCommandSuggestions.test.tsx:11:25
 ❯ src/ui/components/input-overlays/SlashCommandSuggestions.tsx:3:1
            </failure>
        </testcase>
    </testsuite>
</testsuites>
